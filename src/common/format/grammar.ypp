%code top {
  #include "common/format/private/Parser.h"
  #include <cmath>

  struct YYLTYPE;
  union YYSTYPE;

  static int yylex (YYSTYPE *lvalp, YYLTYPE *llocp, FormatterBase::Parser &parser);
  static void yyerror (YYLTYPE *llocp, FormatterBase::Parser &parser, char const *msg);
  static int yyparse (FormatterBase::Parser &parser);
}

%define api.pure
%locations
%parse-param { FormatterBase::Parser &pp }
%lex-param { FormatterBase::Parser &pp }

%debug
%error-verbose

%expect 9

%union {
  Specification	spec;
  Flag		flags;
  Length	length;
  Conversion	conversion;
  int		integer;
}

%start format_string

%type <spec>		string_part conversion_specification

%type <flags>		flags_opt flags flag
%type <length>		length
%type <conversion>	conversion
%type <integer>		operand
%type <integer>		width
%type <integer>		precision

%type <integer>		nzdigit digit digits integer

%token TEXT

%%
format_string
	: string_part		{ pp.specs->push_back ($1); }
	| format_string string_part
				{ pp.specs->push_back ($2); }
	;

string_part
	: TEXT			{
				  $$ = Specification {
				    Flag::NONE,
				    Length::NONE,
				    Conversion::NONE,
				    0, // operand
                                    0, // width
                                    0, // precision
				    pp.begin + @1.first_column,
				    pp.begin + @1.last_column
				  };
				}
	| conversion_specification
	;

conversion_specification
	: '%' operand flags_opt width precision length conversion
				{
				  pp.state = FormatterBase::Parser::STRING;
				  $$ = Specification {
				    $3, // flags
				    $6, // length
				    $7, // conversion
				    $2, // operand
				    $4, // width
				    $5, // precision
				    pp.begin + @1.first_column,
				    pp.begin + @7.last_column
				  };
				}
	;

operand
	: integer '$'
	| /* empty */		{ $$ = 0; }
	;

flags_opt
	: flags
	| /* empty */		{ $$ = Flag::NONE; }
	;

flags
	: flag
	| flags flag		{ $$ = Flag (int ($1) | int ($2)); }
	;

flag
	: '#'			{ $$ = Flag::Alternate;    }
	| '0'			{ $$ = Flag::ZeroPadded;   }
	| '-'			{ $$ = Flag::LeftAdjusted; }
	| ' '			{ $$ = Flag::Blank;        }
	| '+'			{ $$ = Flag::Signed;       }
	| '\''			{ $$ = Flag::Grouped;      }
	| 'I'			{ $$ = Flag::Localised;    }
	;

width
	: integer
	| '*' operand		{ $$ = $2 | Specification::OP_MASK; }
	| /* empty */		{ $$ = 0; }
	;

precision
	: '.' integer		{ $$ = $2; }
	| '.' '*' operand	{ $$ = $3 | Specification::OP_MASK; }
	| /* empty */		{ $$ = 0; }
	;

length
	: 'h' 'h'		{ $$ = Length::hh;   }
	| 'h'			{ $$ = Length::h;    }
	|			{ $$ = Length::NONE; }
	| 'l'			{ $$ = Length::l;    }
	| 'l' 'l'		{ $$ = Length::ll;   }
	| 'L'			{ $$ = Length::L;    }
	| 'j'			{ $$ = Length::j;    }
	| 'z'			{ $$ = Length::z;    }
	| 't'			{ $$ = Length::t;    }
	;

conversion
	: 'd'			{ $$ = Conversion::d; }
	| 'i'			{ $$ = Conversion::i; }
	| 'o'			{ $$ = Conversion::o; }
	| 'u'			{ $$ = Conversion::u; }
	| 'x'			{ $$ = Conversion::x; }
	| 'X'			{ $$ = Conversion::X; }
	| 'e'			{ $$ = Conversion::e; }
	| 'E'			{ $$ = Conversion::E; }
	| 'f'			{ $$ = Conversion::f; }
	| 'F'			{ $$ = Conversion::F; }
	| 'g'			{ $$ = Conversion::g; }
	| 'G'			{ $$ = Conversion::G; }
	| 'a'			{ $$ = Conversion::a; }
	| 'A'			{ $$ = Conversion::A; }
	| 'c'			{ $$ = Conversion::c; }
	| 's'			{ $$ = Conversion::s; }
	| 'p'			{ $$ = Conversion::p; }
	| 'n'			{ $$ = Conversion::n; }
	| 'm'			{ $$ = Conversion::m; }
	| '%'			{ $$ = Conversion::NONE; }
	;

nzdigit
	: '1'			{ $$ = 1; }
	| '2'			{ $$ = 2; }
	| '3'			{ $$ = 3; }
	| '4'			{ $$ = 4; }
	| '5'			{ $$ = 5; }
	| '6'			{ $$ = 6; }
	| '7'			{ $$ = 7; }
	| '8'			{ $$ = 8; }
	| '9'			{ $$ = 9; }
	;

digit
	: '0'			{ $$ = 0; }
	| nzdigit		{ $$ = $1; }
	;

digits
	: digit			{ $$ = $1; }
	| digit digits		{ $$ = $1 * pow (10, (int)log10 ($2) + 1) + $2; }
	;

integer
	: nzdigit		{ $$ = $1; }
	| nzdigit digits	{ $$ = $1 * pow (10, (int)log10 ($2) + 1) + $2; }
	;
%%
#include "common/format/private/code.h"
